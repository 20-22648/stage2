<!DOCTYPE html>
<html lang="ja">





 <!--headにはページを開いた時に表示されない情報を書く-->
<head>

  <meta charset="UTF-8">
  <title>2Dアクションゲーム</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    body { text-align: center; height: 100vh; }
    canvas { background: #eef; display: block; margin: 0 auto; }
    #restart { font-size: 1.2em; padding: 8px 24px; margin-top: 10px; display: none; }
  </style>


  <meta name="robots" content="noindex, nofollow">



</head>





<body>

  <h1>stage2</h1> 
  <p>←↑→で移動</p>


  <!--canvasは図形を描画するための要素-->
  <canvas id="game"></canvas> 
    






  <!--リスタートボタンの処理-->
  <p id="msg"></p>
  <button id="restart">リスタート</button>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restart');
    //タイマー設定


    let startTime = null; // ゲーム開始時刻
    let elapsedTime = 0; // 経過時間
    let timerStarted = false;

    let lastFrameTime = performance.now(); // 前回のフレーム時間








    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 200;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);








    

    // --- ゲームの設定 ---
    const stageLength = 3500; // ステージの横幅
    const groundHeight = 20;  // 地面の厚さ
   // いちいちステージの横幅や地面の座標を入力してもいいが一つの変数にまとめておくと後で変更しやすい






    // --- ステージ構造 ---
    // platforms: 足場（地面以外の床）
    // holes: 穴（奈落）
    // enemies: 敵キャラ
    // obstacles:　当たると死ぬ障害物

    function createStage() {
      const platforms = [
        {x: 0, y: -25, w: 250, h: 50},
        {x: 200, y: 100, w: 100, h: 20},
        {x: 300, y: 250, w: 200, h: 25},
        {x: 700, y: 300, w: 200, h: 25},
        {x: 1000, y: 200, w: 100, h: 25},
        {x: 1400, y: groundHeight, w: 500, h: 25},
        {x: 2000, y: 100, w: 100, h: 25},
        {x: 2200, y: 200, w: 100, h: 25},
        {x: 2500, y: 300, w: 200, h: 25},
        {x: 2815, y: 250, w: 595, h: 25},
        {x: 2515, y: groundHeight, w: 1200, h: 25}, // ゴールの足場
        {x: 2800, y: 155, w: 25, h: 400},
        {x: 2500, y: 20, w: 25, h: 300},
        {x: 2650, y: 155, w: 300, h: 25},
        {x: 2950, y: 155, w: 25, h: 100},
        {x: 2500, y: 555, w: 325, h: 25},



      ];
      // 以下目印　足場配置後は消去-------------------------------
      for (let i = 0; i <= -1; i+= 200) {
        platforms.push({x: i, y: 600, w: 50, h: 50});
      }
      // -----------------------------------------------------











      //　穴（奈落）
      const holes = [
        {x: 0, y: 0, w: stageLength},




      ];










      // 当たると死ぬ障害物
      const obstacles = [
      {x: 550, y: 350, w: 50, h: 50},  
      {x: 3350, y: 200, w: 50, h: 50},
      {x: 3150, y: 35, w: 35, h: 35},
      {x: 950, y: 500, w: 50, h: 50},
      {x: 2525, y: 45, w: 15, h: 255},
      {x: 2790, y: 180, w: 10, h: 200},






       ];










      // 敵キャラ設定
      //x,y,w,hがキャラの大きさ、vxがx軸への動く速度、aiTypeがAIの種類"patrol"（左右移動）, "chase"（プレイヤー追跡）dirが移動方向（1:右, -1:左）、patrolMinとpatrolMaxがパトロール範囲
       const enemies = [
        
        {x: 500, y: 80, w: 40, h: 40, vx: 3, aiType: "patrol", dir: 1, patrolMin: 300, patrolMax: 480},  
        {x: 1800, y: 0, w: 40, h: 40, vx: 3, aiType: "patrol", dir: 1, patrolMin: 1400, patrolMax: 1900},  
        //{x: 500, y: 80, w: 40, h: 40, vx: 2, aiType: "chase"}
        
      ];



      return {platforms, holes, obstacles, enemies};
    }








    // --- ゲームの初期状態情報 ---
    function createInitialState() {


      // プレイヤー初期位置
      const player = {
        x: 50, y: 0, w: 70, h: 70,
        vx: 0, vy: 0,
        speed: 6,
        jumpPower: 16,
        onGround: true
      };


      // カメラ初期位置
      let cameraX = 0;



      const {platforms, holes, obstacles, enemies} = createStage();






      // ゴール位置
      const goal = { x: stageLength - 100, y: 580, w: 40, h: 150 };




      return { player, cameraX, platforms, holes, obstacles, enemies, goal };
    }


    let { player, cameraX, platforms, holes, obstacles, enemies, goal } = createInitialState();
    let gameOver = false;
    let gameClear = false;





    // キー入力管理
    const keys = {};
    document.addEventListener('keydown', e => {

      keys[e.key] = true;
      if (!timerStarted && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp')) {
        timerStarted = true;
        startTime = performance.now(); // ゲーム開始時刻を記録
      }
      if (e.key === 'ArrowUp' && player.onGround && !gameOver && !gameClear) {
        player.vy = -player.jumpPower;
        player.onGround = false;
      }

    });


    document.addEventListener('keyup', e => {keys[e.key] = false;});






    // --- プレイヤー,足場,穴,障害物,敵の判定 ---
    function update() {


      // プレイヤー横移動
      if (keys['ArrowLeft']) player.vx = -player.speed;
      else if (keys['ArrowRight']) player.vx = player.speed;
      else player.vx = 0;

      player.x += player.vx;

      // ステージ外制限
      player.x = Math.max(0, Math.min(stageLength - player.w, player.x));








      // ジャンプ、重力処理
      player.vy += 0.6; // 重力
      player.y += player.vy;







      // 足場・地面判定
      let onAnyPlatform = false;
      for (const pf of platforms) {
        const pfY = canvas.height - groundHeight - (pf.y || 0) - pf.h;

        if (
          player.x + player.w > pf.x &&
          player.x < pf.x + pf.w &&
          player.y + player.h >= pfY &&
          player.y + player.h - player.vy <= pfY + 4 &&   // !--すり抜け防止前フレ判定、4フレマージン、break処理,下と左右も追加？--！
          player.vy >= 0
        ) {
          player.y = pfY - player.h;
          player.vy = 0;
          player.onGround = true;
          onAnyPlatform = true;
          break; 
        }

        if (
          player.x + player.w > pf.x &&
          player.x < pf.x + pf.w &&
          player.y <= pfY + pf.h &&
          player.y >= pfY + pf.h - 16 && 
          player.vy < 0
        ) {
          player.y = pfY + pf.h;
          player.vy = 0;
          break;
        }

        // 左からぶつかった場合
        if (
          player.vx > 0 && // 右に移動中
          player.x + player.w > pf.x && // プレイヤー右端が足場左端を超えた
          player.x < pf.x && // プレイヤー左端は足場左端より左
          player.y + player.h > pfY + 2 && 
          player.y < pfY + pf.h - 2
        ) {
          player.x = pf.x - player.w;
          break;
        }

        // 右からぶつかった場合
        if (
          player.vx < 0 && // 左に移動中
          player.x < pf.x + pf.w && // プレイヤー左端が足場右端を超えた
          player.x + player.w > pf.x + pf.w && // プレイヤー右端は足場右端より右
          player.y + player.h > pfY + 2 && 
          player.y < pfY + pf.h - 2
        ) {
          player.x = pf.x + pf.w;
          break;
        }
      }

      if (!onAnyPlatform) player.onGround = false;











      // 奈落判定
      let inHole = false;
      for (const hole of holes) {
        if (
          player.x + player.w > hole.x &&
          player.x < hole.x + hole.w &&
          player.y + player.h >= canvas.height - groundHeight + 100
        ) {
          inHole = true;
        }
      }
      if (player.y + player.h >= canvas.height - groundHeight + 100 && inHole) {
        gameOver = true;
        document.getElementById('msg').textContent = '奈落に落ちた';
        restartBtn.style.display = 'inline-block';
      }












      // 障害物判定
      for (const obs of obstacles) {
        const obsY = canvas.height - groundHeight - (obs.y || 0) - obs.h;
        if (
          player.x < obs.x + obs.w &&
          player.x + player.w > obs.x &&
          player.y < obsY + obs.h &&
          player.y + player.h > obsY
        ) {
          gameOver = true;
          document.getElementById('msg').textContent = '障害物に当たった';
          restartBtn.style.display = 'inline-block';
        }
      }

















      // ---敵モブ情報 ---
      for (const enemy of enemies) {
      
      
      
      
      
      
        // 足場上に配置
        let ey = canvas.height - groundHeight - enemy.h;
        for (const pf of platforms) {
          const pfY = canvas.height - groundHeight - (pf.y || 0) - pf.h;
          if (
            enemy.x + enemy.w > pf.x &&
            enemy.x < pf.x + pf.w
          ) {
            ey = pfY - enemy.h;
          }
        }
        enemy.y = ey;









        // モブごとの設定
        if (enemy.aiType === "patrol") {
          enemy.x += enemy.vx * enemy.dir;
          if (enemy.x < enemy.patrolMin) {
            enemy.x = enemy.patrolMin;
            enemy.dir = 1;
          }
          if (enemy.x > enemy.patrolMax) {
            enemy.x = enemy.patrolMax;
            enemy.dir = -1;
          }
        } else if (enemy.aiType === "chase") {        //←chase型の方が明らかに処理が簡単
          if (player.x > enemy.x) enemy.x += 4.1;
        }






      



        // 敵モブの足場判定
        let enemyOnPlatform = false;
        for (const pf of platforms) {
          const pfY = canvas.height - groundHeight - (pf.y || 0) - pf.h;
          if (
            enemy.x + enemy.w > pf.x &&
            enemy.x < pf.x + pf.w &&
            enemy.y + enemy.h >= pfY &&
            enemy.y + enemy.h <= pfY + 16 &&
            enemy.vy >= 0
          ) {
            enemy.y = pfY - enemy.h;
            enemy.vy = 0;
            enemy.onGround = true;
            enemyOnPlatform = true;
          }
        }
        if (!enemyOnPlatform) enemy.onGround = false;










        // プレイヤーとの衝突
        if (
          player.x < enemy.x + enemy.w &&
          player.x + player.w > enemy.x &&
          player.y < enemy.y + enemy.h &&
          player.y + player.h > enemy.y
        ) {
          gameOver = true;
          document.getElementById('msg').textContent = '敵に倒された';
          restartBtn.style.display = 'inline-block';
        }
      }














      // ゴール判定
      //goal.y = canvas.height - groundHeight - goal.h;
      if (
        player.x < goal.x + goal.w &&
        player.x + player.w > goal.x &&
        player.y < goal.y + goal.h &&
        player.y + player.h > goal.y
      ) {
        gameClear = true;
        document.getElementById('msg').textContent = 'クリア！';
        restartBtn.style.display = 'inline-block';
      }










      // カメラ追従
      cameraX = player.x - canvas.width / 2 + player.w / 2;
      cameraX = Math.max(0, Math.min(stageLength - canvas.width, cameraX));
    }










    // 画像
const playerImg = new Image();
playerImg.src = 'Mario2_transparent.png'; // プレイヤー画像

const enemyImg = new Image();
enemyImg.src = 'enemypatrol.png'; // patrol型敵画像ファイル

const enemyImg1 = new Image();
enemyImg1.src = 'enemypatrol.png'; // 1枚目
const enemyImg2 = new Image();
enemyImg2.src = 'enemypatrol2.png'; // 2枚目

// --- アニメーション用タイマー ---
let enemyAnimFrame = 0;
setInterval(() => {
  enemyAnimFrame = (enemyAnimFrame + 1) % 2;
}, 500); // 1秒ごと











    // --- 描画 ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);


      //タイマーの描画
      ctx.save();
      ctx.font = '35px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'right';
      ctx.fillText("time : " + (elapsedTime / 1000).toFixed(2) + "s", canvas.width - 15, 30 );
      ctx.restore();



      // 穴の描画
      for (const hole of holes) {
        ctx.fillStyle = '#EEEEFF';
        ctx.fillRect(hole.x - cameraX, canvas.height - groundHeight, hole.w, groundHeight);
      }








      // 足場の描画
      for (const pf of platforms) {
        ctx.fillStyle = pf.y ? '#aaa' : '#888';
        const pfY = canvas.height - groundHeight - (pf.y || 0) - pf.h;
        ctx.fillRect(pf.x - cameraX, pfY, pf.w, pf.h);
      }










      // ゴール描画
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(goal.x - cameraX, goal.y, goal.w, goal.h);












      // 障害物描画
      ctx.fillStyle = '#e74c3c';
      for (const obs of obstacles) {
        const obsY = canvas.height - groundHeight - (obs.y || 0) - obs.h;
        ctx.fillRect(obs.x - cameraX, obsY, obs.w, obs.h);
      }











      //敵描画
      // --- 描画 ---
      // --- 描画 ---
     for (const enemy of enemies) {

      let img = (enemyAnimFrame === 0) ? enemyImg1 : enemyImg2;

      if (img && img.complete && img.naturalWidth > 0) {
        ctx.save();

       if (enemy.dir && enemy.dir < 0) {
         ctx.translate(enemy.x - cameraX + enemy.w / 2, enemy.y + enemy.h / 2);
         ctx.scale(-1, 1);
         ctx.drawImage(img, -enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
        } else {
          ctx.drawImage(img, enemy.x - cameraX, enemy.y, enemy.w, enemy.h);
        }
        ctx.restore();
        } else {
         ctx.fillStyle = "#27ae60";
         ctx.fillRect(enemy.x - cameraX, enemy.y, enemy.w, enemy.h);
        }
      }

      /*
const enemies = [
        
]
      */






      // プレイヤー描画
      if (playerImg.complete && playerImg.naturalWidth > 0) {
        ctx.drawImage(playerImg, player.x - cameraX, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = '#3498db';
        ctx.fillRect(player.x - cameraX, player.y, player.w, player.h);
      }
    }


















































    /*
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    */
    // 以下ループ処理
    function loop() {
      
      if (!gameOver && !gameClear) {
        if (timerStarted && startTime !== null) {
          elapsedTime = performance.now() - startTime;
        }
        update();
        draw();
        requestAnimationFrame(loop);
      } else {
        draw();
      }
    }


    //初期位置調整
    function setInitialPositions() {
      const groundY = canvas.height - groundHeight - player.h;
      player.y = groundY - 40;
      for (const obs of obstacles) {}
      
      for (const enemy of enemies) {
        enemy.y = canvas.height - groundHeight - enemy.h;
      }
    //goal.y = canvas.height - groundHeight - goal.h;
    }
    setInitialPositions();

    loop();

    //リスタート処理
    restartBtn.addEventListener('click', () => {
    // 状態初期化
      ({ player, cameraX, platforms, holes, obstacles, enemies, goal } = createInitialState());
      gameOver = false;
      gameClear = false;
      document.getElementById('msg').textContent = '';
      restartBtn.style.display = 'none';
      setInitialPositions();
      startTime = null; // リスタート時にタイマーをリセット
      elapsedTime = 0; // リスタート時に経過時間をリセット
      lastFrameTime = performance.now(); // リスタート時にフレームタイムをリセット
      timerStarted = false; // リスタート時にタイマーをリセット
      loop();
    });
    if (document.referrer !== "https://plactice.neocities.org/stageselect") {
      location.href = "null";
    }
  </script>
</body>
</html>
